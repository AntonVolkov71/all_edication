
- Если пишешь О(n) указывать что за n.
- Опускать константы 2*n
- Описывать худший, средний, лучший случай. При этом если худший это редко, то тогда средний, и наоборот. Но лучше упомянуть о худшем случае.
- Учитывать язык, массив вставка амортизированная сложность. Строка не изменяема. И так далее. Это не O(1)...
- Присчитывание сложности, написать что ввод и вывод не учитываются. Выносить ввод и вывод в отдельные методы
- O(n+m) = O(max(n m)), два прохода, а два прохода это n. Поэтому берём максимальный и остальное не учитываем

### степень числа
- Степень числа 4 от Х -> это log4 Х = (logz X) /(logz4) = logX / Log4

### целочисленное деление
const a = 10
const b = 3

console.log(~~(a / b))
console.log(Math.floor(a / b))
console.log(parseInt(a / b))


### Хеш Коэффициент заполнения
    * α = N / M, N - кол-во элементов, M - кол-во корзин (простое число)
    * Средняя сложность операций над хеш-таблицами составляет O(1+α)
    * Оптимальный коэффициент заполнения, обеспечивающий неплохое соотношение между скоростью программы и объёмом
      потребляемой памяти, примерно равен 1. Например, в Java по умолчанию используется метод цепочек с коэффициентом
      заполнения 0.75. При отходе от этого значения (допустим, когда α>1.25 или α<0.5), требуется изменение числа
      корзин. Python использует метод открытой адресации и поддерживает коэффициент заполнения в промежутке от 1/3 до 2/3.
    * увеличивать M (число корзин) - на следующее простое число (т.к. оно примерно всегда больше в 2 раза) - ПЕРЕМЕЩАЕМ ВСЕ

### Увеличение числа корзин хеш-таблицы - Рехеширование O(n), но амортизированная средняя О(1)

## Построение хеш-функций для строк
Для этого есть специальный алгоритм, который называется «полиномиальным хешированием» (от слова «полином» — многочлен).
Хеш строки s вычисляется по формуле:

h(s)=(s1q (n−1)  +s2q  n−2 n−1 q+s n)modR
Где i — код i-го символа (например, ASCII-код),n — длина строки, а R и q — выбранные константы.


### Дерево на массиве
    * индекс корня дерева всегда равен 1
    * индекс родителя узла i равен [i/2], где [x] означает отбрасывание дробной части x;
    * индекс левого потомка узла i равен 2i
    * индекс правого потомка узла i равен 2i + 1