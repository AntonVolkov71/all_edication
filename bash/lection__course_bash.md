### Проверка вы в Bash или нет
    * $ declare -p BASH - если ответ типа такого $ declare -- BASH="/bin/bash"

### Узнать, что за оболочка
    * $ echo "$SHELL"

### Goto BASH
    * $ bash

### Check Version
    * $ declare -p BASH_VERSION
    * $ bash --version

### Install Bash
    * $ sudo apt-get install bash
    * $ sudo apt-get update

### Structure simple commands Bash
    * $ command [options] [arguments]
    * $ mkdir -p new/bash
            mkdir    - command создать директорию
            -p       - option можно создавать new/bash/other, без только одну директорию
            new/bash - относительный путь к создаваемому каталогу

### Создать файл
    * $ touch new_file.txt
    * метасимволы нельзя использовать в названиях папок, файлов - Пробел, табуляция |, &, ; , (  )  <  >
    * {, [, * и $, но они не считаются метасимволами
    * но если хотим название из раздельных слов
        * touch "ona two.txt" - quoting
        * touch "ona\ two.txt" - экранирование  (escaping)
            $ touch Testfile\<Tom\>.doc
            $ touch Review\;Final.doc
            $ touch \$\$\$Money.doc
            $ echo \\backslash\\ - в названии косая черта
    * \  - игнорирует перевод строки
    * '' - позволяют перевод строки
    * touch "file_with_one_quote's2.txt" - ' - одна кавычка в названии
    * $  - экранируем \$
    * !  - экранируем \! или одинарные кавычки '!'
    * `  - экранируем \`

### Двойные кавычки
    * чтобы использовать переменную, можно несколько раз в одной команде
    * нет конкатенации oneWord + secondWord просто друг за другом
    * "This is my login shell: $SHELL"
        - -bash: this is my login shell: /bin/bash:
    * 'This is my login shell: $SHELL' - не сработает
        - this is my login shell: $SHELL: command not found
    * echo my login "$USER" and hostname "$HOSTNAME"

### Последовательное выполнение команд (интерактивное)
    * разделяется точкой с запятой
        * $ ls; touch new_file.txt
    * при таком следующая команда выполнить независимо от результата предыдущей
    * cd - без параметров переход к домашнему каталогу ( cd ~ или cd --"$HOME")

### Результат выполнения команды
    * echo $? - ввести после команды
        1 - ошибка  - $ false; echo $?
        0 - успешно - $ true; echo $?
        127 - состояние выхода, не такой команды - notnotn; echo $?
    * 0 - работа завершилась без ошибок (приложение, команды и т.д.)
    * остальные - значения выхода при условии ошибки


### Остановка списка команд в случае ошибки
    * $ rmdir tetetet && ls                   - остановится если директории tetetet не существует, ls - не выполнится
    * $ rmdir tetetet || rmdir tetetet || ls  - если надо выполнить пока статус одной из команды не будет успешный
        - два раза неудачно выполниться rmdir и в конце ls
    * $ ls || ls                              - выполниться один раз, так как ls первая удачна

### Выполнение команды в фоновом режиме
    * параллельное и неожидающее завершения текущей
    * $ sleep 5   - без & в конце нельзя будет выполнить какую-либо другую команду
    * $ sleep 5 & - команда уйдет в фон, можно выполнять другие команды, sleep когда завершиться уведомит

## Основные типы команд

### Встроенные команды
* $ type: Определение типа команды
* $ echo: Печать аргументов
* $ printf: Печать отформатированных аргументов
* $ pwd: Печать текущего каталога
* $ cd: Изменение текущего каталога
* $ set: Просмотр и установка свойств оболочки
* $ declare: Управление переменными и функциями
* $ test, [, [[: Оценка выражений

### Системные команды
    * $ ls: Вывод списка файлов для пользователей
    * $ mv: Перемещение и переименование файлов
    * $ cp: Копирование файлов
    * $ rm и rmdir: Удаление файлов и каталогов
    * $ grep: Поиск шаблонов
    * $ cut: Извлечение столбцов из данных
    * $ wc: Подсчет строк, слов и символов
    * $ find: Итерация по дереву файлов
    * $ sort и uniq: Сортировка и унификация вводимых данных
    * $ ping: для проверки доступности сетевого узла

### Команды времени выполнения
    * $ alias name='echo Your name is Anton' - типа как переменная
        * $ name
    * $ my_function() { echo "Hello, World!"; }
        * $ my_function

### Команда type
    * дает вам информацию о том, что это за команда
    * $ type echo   - echo is a shell builtin
    * $ type for    - for is a shell keyword
    * $ type grep   - grep is aliased to `grep --color=auto'
    * $ type my_function
        - my_function is a function
        - my_function ()
            {
                echo "Hello, World!"
            }
    * опции
        * $ type -t echo    - builtin - получить одно слово это полезно в скриптах
        * $ type -a true    - все команды с одинаковыми именами
                - true is a shell builtin
                - true is /usr/bin/true
                - true is /bin/true
        * $ type -P grep
        /usr/bin/grep       - выводить путь к команде

### Команда echo
    * просто повторяет аргументы, которые вы ей предоставляете
    * $ echo Hello               - Hello
    * $ echo 'Hello, '"$USER"\!  - упрощает передачу содержимого в терминал, включая переменные
    * $ echo -en "Hello\world\n"  - \t \n - перед использованием подобных символов стоит добавить опцию -en
    * использование echo в скриптах нежелательно -> Рекомендуется использовать printf

### Команда printf
    * работает как echo, за исключением того, что первый аргумент, который вы ей предоставляете, является строкой
    * $ printf '%s\n' 'Hello!' 'Hello2' - каждый аргумент с новой строки
    * можете использовать printf во многом так же, как использовали бы функцию printf() на других языках, таких как C
    * $ string=Anton; $ printf '%s\n' "$string" - задать переменную и распечатать ее

### Команда pwd
    * $ pwd            - выводит текущий рабочий каталог
    * $ echo ~         - Путь до домашней директории
    * $ echo ~volkov   - проверка пути до директории юзера
        - /home/volkov - если существует
        - ~volkovw     - не существует, вернет исходное значение ввода
    * $ echo \~volkov  - если надо напечатать без поиска каталога

### Команда cd
    * $ cd /dir   - устанавливает рабочий каталог
    * $ cd        - без аргументов установит домашний каталог (сначала считывает переменную окружения $HOME)

### Команда set
    * отображает имена
    * устанавливает параметры оболочки
    * устанавливает позиционные параметры оболочки
    * $ set       - без аргументов, выводит список всех переменных и любых функций для запущенной оболочки
    * $ declare   - тоже самое, что $ set только больше информации
    * опции для set:
        * -e      - немедленное завершение команды, если команда завершается с ненулевым статусом
                  - лучше написать собственную обработку ошибок для всех сценариев, кроме самых простых
        * -n      - Считывайте команды, но не выполняйте их. Это полезный способ проверить,
                  - что ваш скрипт Bash синтаксически корректен, фактически не выполняя ни одну из команд
        * -v      - Выводит строки ввода оболочки по мере их считывания. Это может быть полезно для отладки,
                  - но показывает не так много информации, как -x
        * -x      - выводит команды и их аргументы по мере их выполнения. Включение этой опции часто является
                  - очень хорошим первым шагом для отладки скрипта Bash, поскольку она показывает вам,
                  - как программа bash интерпретировала и расширила свои входные данные.

### Команда declare
    * встроенной командой оболочки Bash и не всегда является стандартной командой в других оболочках
    * устанавливает или отображает переменные (включая массивы) и функции
    * используется для определения типов переменных, назначения атрибутов, и создания локальных переменных внутри функций
    * $ declare -a arr=(2, 44)   - объявить массив
    * $ echo $arr                - вывести переменную arr
    * $ echo ${arr[0]}           - вывести первый элемент arr
    * $ declare -p BASH PWD      - можно без доллара, напечатает результаты только для этих переменных
    * опции:
        * -r                     - только для чтения (нельзя переопределить)
        * -i                     - целочисленная переменная
        * -a                     - переменная массив
        * -f                     - все функции, определенные для вашей оболочки

### Команды test,[, и [[
    * используется для вычисления условных выражений
    * test и [ и [[                                         - одно и тоже
    * $ test -e file.txt && echo 'Password file exists!'    - если файл существует, выведет надпись
                                                            - если не существует ничего
    * test -e file тоже самое [ -e file ]                   - обязательно закрывать [ <command> ]
    * [[ -e file ]]                                         - тоже самое, но лучше читаемое

### Невстроенные команды env и printenv
    * $ printenv и $ env        - печатают переменные среды, env больше функций
    * $ printenv USER             - выводит значение переменной
    * env [ОПЦИЯ]... [-][ИМЯ=ЗНАЧЕНИЕ]... [КОМАНДА [АРГУМЕНТ]...]
    * env опция:
        * -u                    - удалить env -u $HOLIDAY

### Файловая система
    * Linux поддерживает:
        * ext3
        * ext4
        * squashfs
        * btrfs
    * журналируемые
        * ext4, xfs, btrfs и jfs
        * Windows (ntfs, vfat)
        * СГИ (xfs)
        * IBM (JFS)
        * MacOS (hfs, hfs+)
    * нежурналируемые
    * Каждая файловая система в системе Linux занимает раздел диска
    * root - отдельно для запуска системы
    * home - файлы, принадлежащие обычным пользователям этой системы
    * другие, например, для временных файлов
    * $ df -Th              - посмотреть список доступных разделов


### Структура каталогов в Linux
    * / (корневой раздел):                          - Это самый верхний уровень файловой системы Linux. Все остальные
                                                      разделы и каталоги располагаются внутри корневого раздела.
                                                      Здесь хранятся основные системные файлы и каталоги.

    * /bin (бинарные файлы):                        - Этот каталог содержит исполняемые файлы, необходимые для загрузки
                                                      и функционирования системы в одно пользовательском
                                                      режиме (single-user mode).

    * /boot (загрузочные файлы):                    - Здесь хранятся файлы, необходимые для загрузки операционной системы,
                                                      такие как ядра Linux и конфигурационные файлы загрузчика.

    * /dev (устройства):                            - Этот каталог содержит специальные файлы, представляющие драйверы,
                                                      подключенные к системе. Они используются для взаимодействия
                                                      с аппаратными устройствами.

    * /etc (конфигурационные файлы):                - Здесь хранятся конфигурационные файлы системы и устанавливаемых
                                                      приложений.

    * /home (домашние каталоги):                    - В этом разделе находятся домашние каталоги пользователей. Каждый
                                                      пользователь здесь имеет свой собственный подкаталог со своими файлами.

    * /lib и /lib64 (библиотеки):                   - Эти каталоги содержат системные библиотеки, необходимые для работы
                                                      программ и драйверов.

    * /media и /mnt (точки монтирования):           - Здесь монтируются временные файловые системы и внешние устройства,
                                                      такие как USB-флешки и сетевые ресурсы.

    * /opt (дополнительное программное обеспечение) - Этот каталог предназначен для установки дополнительного программного
                                                      обеспечения, которое не является частью основной системы.

    * /proc и /sys (процесс и системная информация) - Эти каталоги предоставляют информацию о текущих процессах и системных
                                                      настройках через файловую систему.

    * /srv (служебные данные):                      - Этот каталог используется для хранения данных, связанных с службами,
                                                      предоставляемыми системой.

    * /tmp (временные файлы):                       - Здесь размещаются временные файлы, которые могут быть удалены при
                                                      перезагрузке системы.

    * /usr (дополнительные установки):              - Здесь хранятся все пользовательские программы ( /usr/bin ) ,
                                                      библиотеки ( /usr/lib ), документация ( /usr/share/doc ) и т.д.

    * /var (файлы длительного хранения):            - Каталог /var предназначен для файлов длительного хранения,
                                                      создаваемых программами. Многие программы ведут протоколы своей
                                                      деятельности, эти протоколы складываются обычно в /var/log


### Команды для навигация по файлам и директориям
    * $ ls                  - список файлов в текущем каталоге, напечатанные горизонтально
        * -i                - Для просмотра номеров индексных дескрипторов файлов (уникальный идентификатор 'inode')
        * -a                - скрытые, файлы с точкой
        * -l                - подробная информация файлов (drwxr-xr-x   8 root root    4096 Dec 28 09:38 mnt)
        * -1                - список вертикально
        * -F:               - пометка каталогов при помощи обратной косой черты
        * -s, -r:           - сортировка по имени файла в алфавитном и обратном порядке, соответственно
        * -X:               - сортировка вывода в алфавитном порядке по расширению записи
        * -R:               - древовидное представление вывода
        * -n:               - вывод UID (уникальный идентификатор) и GID (идентификатор группы) файлов
        * -lh:              - вывод размерности файла в понятном виде
        * -lh:              - вывод размерности файла в понятном виде
            * $ ls -l --block-size=B file.txt - B, G, M, K - килобайты, мегабайты, гигабайты
            * $ stat file.txt                              - метаданные файла в байтах
            * $ stat -c %s lecture.txt                     - только размер
            * $ du -h lecture.txt                          - размер и имя файла
            * $ du -h ~/Изображения/*                      - списком размеры все файлов и имен
            * $ du -sh test/                               - размер папки и имя
            * $ du -k test/                                - размер подпапок и их имена
            * $ wc -c lecture.                             - размер файла и имя байты

### Операции с файлами
    * $ cp                              - копирование файлов
        * -R olddir newdir              - рекурсивное копирование всех файлов и каталогов внутри копируемой папки
        * -Rv olddir newdir             - вывод на печать результата каждой директории и файла
             -  'test' -> 'newdir'
             -  'test/new file.txt' -> 'newdir/new file.txt'
    * $ mv                              - перемещение с автоматическим перезаписыванием
        * -i                            - спросит перезаписать если существует такой файл

        * Приведенный сценарий сначала переместит customers в customers-old, если целевой файл уже существует.
            #!/bin/bash
            if [[ -e customers ]] ; then
             printf 'Файл customers уже существует, переименование\n'
             mv customers customers-old
            fi
            mv customers-new customers

### Поиск файлов и каталогов
    * $ find ./cource_bash/ ./other_dir test.txt      - рекурсивный поиск внутри cource_bash и other_dir
    * $ find . -name '*file*' -print                  - выведет в названии которого присутствует строка file в имени файла.
    * $ find . git -name '.git*' -prune -o -print     - игнор папок и файлов, которые начинаются с .git

### Сортировка и уникальные значения
    * $ sort test/test.txt test/test2.txt             - вывод из двух файлов строк совмещенные и отсортированные
        * -n                                          - сортировка по числам (10 будет после 9)
        * -r                                          - противоположная сортировка
    * $ printf '%s\n' 'line 2' 'line 1'  | sort       - сортировка строк с выводом на новую строку
    * $ sort  test/test.txt | uniq -c                 - сортировка текста файла и покажет кол-во вхождений одинаковых

### Создание директории
    * $ mkdir newdir                                  - создание директории
        * -v                                          - вывод результата каждой команды
        * -p                                          - создает родительскую папку если ее нет ($ mkdir newdir/dir/dir -p)

### Удаление директорий и файлов
    * $ rm file.txt                                   - безвозвратное удаление файла
    * $ rm -R (-r) dir                                - безвозвратное удаление директории !!ОПАСНО!! удалит даже с файлами
    * $ rmdir dir                                     - удалит только пустую директорию

### Создание файла (команда touch)
    * $ touch newfile newfile2                        - создание файла/файлов,
        * если такой файл существует, он не измениться, а измениться временные метки
        * -с                                          - оставить временные метки прежние!

### Просмотр содержимого файла
    * $ cat file.txt                                  - вывод содержимого в терминал
    * $ cat file1.txt > file2.txt                     - Если file2.txt не существует, то создаст его.
                                                        В противном случае он перезапишет файл
### Подсчет количества строк при помощи команды wc
    * $ wc file2.txt                                  - 12  52 245 file2.txt (12 строк, 52 слова, 245 размер в байтах
        * -l                                          - вывод только строк
        * -w                                          - вывод только слов
        * -c                                          - вывод только размера

### Поиск содержимого при помощи регулярных выражений
    * $ grep 'anton' file1.txt
        * -c                                          - кол-во совпадений
        * -e                                          - поиск по нескольким (-e 'one' -e 'two')
        * -F                                          - поиск как строку для спец символов (-F '$' будет искать знак доллар)
        * -v                                          - инверсия результата (выведет что не совпадает)
        * -q                                          - не будет выводит результат (но результат команды сохраняется)
            * $ grep '^anton' file1.txt -q && echo 'Anton is matched'
    * регулярный поиск
        * '^word'                                     - строка начинается с word
        * 'word$'                                     - строка заканчивается на word

### Ввод, вывод и перенаправление
    * $ printf 'Hello' > file                         - перезапишет и вставит в файл Hello, если файла не сущ создаст его
    * $ set -C                                        - установить запрет перезаписи файла
    * $ printf 'Hello world' >| file                  - игнор на запрет
    * $ printf 'hello3\n' >> file                     - добавить в файл
    * $ grep 'anton' tt >> matches 2>> errors         - ошибку добавит в errors, успех в matched
    * $ grep 'anton' tt >> matches 2>&1               - успех и ошибка сохранить в matched
    * $ printf 'Heellooo' | tee file file1            - Отправка вывода в несколько мест
            * tee -a                                  - добавление, а не перезапись
    * $ cat myfile1 | tr a-z A-Z >| upper             - сделать все заглавные и перенаправить в файл
        * |                                           - получение на вход данных
        * tr a-z A-Z < myfile1                        - получение на вход аналогично |
        *  < myfile1 tr a-z A-Z                       - получение на вход аналогично | и <
    * cat <<'EOF'                                     - Синтаксис here-document - EOF (принято) но может быть любая строка
      foo command help:
      -h, --help: Show this help
      -q, --quiet: Run without diagnostics
      -v, --verbose: Add extra diagnostics
      EOF
        * Синтаксис here-document выглядит следующим образом:
              command <<MARKER
              text
              text
              ...
              MARKER
                * command: Команда, которой передаются данные из here-document.
                * MARKER: Уникальный маркер, который указывает начало и конец блока текста.
                        Маркер может быть любой строкой,
                        и важно, чтобы он не содержал пробельных символов перед и после.
        * Пример использования here-document для создания переменной:
              message=$(cat <<EOS
              This is a multiline message.
              It spans multiple lines.
              EOS
              )

              echo "$message"
              Здесь $(cat <<EOS ... EOS) создает переменную message, содержащую многострочный текст.

### Использование пайпов
    * скрипт - сделать строчными -> сортировка -> уникальность      - при обычной схеме будет создан файл каждый раз
        * $ tr A-Z a-z < words > words.lower
        * $ sort < words.lower > words.sort
        * $ uniq -c < words.sort > word.freq
    * предпочтительнее не использовать временные файлы, свести весь сценарий к одному конвейеру
        * $ tr A-Z a-z < file | sort | uniq -c | sort -k1,1nr > filesort
    * $ { date ; hostname ; } | tr a-z A-Z >> mayd                  - Объединение вывода нескольких программ
    * $ { date ; printf '%s\n' apple carrot ; } > tests             - аналогично выполнение 2 программ и объединение


## Фильтрация программ
### Редактор потоков при помощи sed
    * $ sed ' ' manual                - ' ' ничего не задано просто выведет весь документ
        * '1d', '1,2d'                - удалит первую (1 и 2) строку - d удалить - и выведет
    * $ sed '1,/commands/d' manual    - удаления всех строк, начиная с "1" и до следующего вхождения слова "commands"
    * $ sed 's/stream/river/' manual  - заменяет регулярное выражение в заданную замену
        * Синтаксис s/pattern/replacement/

### Управление процессами
    * Ожидание                        — процесс ожидает сигнала для запуска или выделения системных ресурсов;
    * Выполнение                      — процесс запущен, либо готов к запуску;
    * Завершен                        — процесс был остановлен, получением сигнала завершения работы;
    * Состояние зомби                 — состояние, при котором процесс мертв и не существует, но продолжает значиться
                                        в таблице процессов. Такое состояние может возникнуть, например, когда дочерний
                                        процесс завершился, но родительский элемент не получил сигнал об этом. В таком
                                        случае зомби-процесс нельзя уничтожить без уничтожения его родительского
                                        процесса, т.е вызвав функцию wait().
    * Состояние сироты                — такой статус получают дочерние процессы, когда родительский процесс,
                                        породивший их завершается раньше них. В таком случае им в качестве нового
                                        родителя назначается init-процесс.

    * $ man ps                        - просмотра всех возможных состояний процесса
    * & kill %1                       - убить процесс по идентификатору Задачи
    * & kill 999                      - убить процесс по идентификатору PID
        - sleep 10 & -> [1] 481       - [1] идентификатор Задачи
        * -15                         - убить с сигналом SIGTERM
        * -9                          - убить с сигналом SIGKILL (Мгновенно убивает)
        * -l                          - список сигналов
    * $ kill %sl                      - убить процесс название начинается на sl
    * $ kill %?sl                     - убить процесс название содержит на sl
    * $ kill %%                       - убить последнее задание на переднем плане, либо в фоне
    * $ kill %%+                      - убить последнее задание на переднем плане, либо в фоне
    * $ kill %%-                      - убить последний процесс в фоне
    * $ killall sleep                 - убивать по названию процесса (если таких несколько, убьет все)
    * $ ps -jf                        - список процессов
    * $ jobs                          - список процессов в фоне
        * [1]+ sleep 10 &             - + плюсик - текущее, если минус то предыдущее
    * $ fg %1                         - фоновый процесс на передний план по идентификатору Задачи
    * $ bg %1                         - фоновый процесс на задний план по идентификатору Задачи
    * $ suspend                       - (приостановить): Приостанавливает работу оболочки до получения сигнала SIGCONT.
    * $ logout                        - Выход из оболочки входа в систему
    * $ disown                        - Удаляет ОДНО (последнее) задание из таблицы активных заданий оболочки.
    * $ times                         - время, прошедшее за время выполнения команды
    * $ command ls                    - отключает Псевдонимы (alias) для ls
    * $ builtin                       - Выполняет встроенную команду, отключая функции и не встроенные команды,
                                        которые имеют то же имя, что и встроенная.

### Описание столбцов ps:
    - UID - имя пользователя, от имени которого работает процесс;
    - PID - идентификатор процесса;
    - PPID - идентификатор родительского процесса;
    - C - расходование ресурсов процессора, в процентах;
    - SZ - размер процесса;
    - RSS - реальный размер процесса в памяти;
    - PSR - ядро процессора, на котором выполняется процесс;
    - STIME - время, когда процесс был запущен;
    - TTY - если процесс привязан к терминалу, то здесь будет выведен его номер;
    - TIME - общее время выполнения процесса (user + system);
    - CMD - команда, которой был запущен процесс, если программа не может прочитать аргументы процесса, он будет
            выведен в квадратных скобках;

### Замена процессов
    - это удобный способ передать выходные/входные данные нескольких команд /процессов на вход/выход другого процесса.
     Стандартный способ управления заменой процесса соответствует следующему синтаксису

     * >(list_of_commands)
     * <(list_of_commands)

     * $  wc -l <(ps -f)         -  выходные данные ps -fj были переданы в качестве входных данных для wc -l

### Копроцессы (сопроцессы)
    * $ compoc (NAME) command (redirections)            - процесс в фоновом режиме в асинхронной подоболочке.
                                                        - программами, которые могут быть запущены в CLI и могут читать
                                                          из stdin и писать в stdout, лучше, если с небуферизованным потоком
                                                        - Одновременно может быть только один активный сопроцесс.
    * $ coproc { while true ; do ls ; done }            - Если имя не указано, то по умолчанию будет задано как COPROC
                                                        - COPROC_PID, которая является именем переменной по умолчанию,
    * $ echo $COPROC_PID                                - получить значение PID из переменной COPROC_PID
    * При выполнении coprocess оболочка создает переменную массива с именем NAME, которая содержит две части информации:
          - NAME[0]: Здесь хранится дескриптор выходного файла для сопроцесса
          - NAME[1]:Здесь находится дескриптор входного файла для сопроцесса
          * & echo ${COPROC[0]}
          * & echo ${COPROC[1]}
    * $ ls -la /proc/31067/fd                           - какие файлы открыты для текущего процесса
    * $ echo data >&"${COPROC[1]}"                      - передать данные в coprocess
    * $ read variable <&"${COPROC[0]}"                  - получения данных из сопроцесса
        #!/bin/bash                                     -
            coproc bc_calc { bc; }
            in=${bc_calc[1]}
            out=${bc_calc[0]}
            echo '10*20' >&$in
            read -u $out myvar
            echo $myvar

### Выполнение заданий после закрытия окна терминала
    - задания, выполняемые в фоновом или переднем плане, все задания будут завершены, если вы закроете окно терминала.
      Задания завершаются потому, что они связаны с этим конкретным сеансом терминала. И при выходе из него всем
      запущенным процессам посылается сигнал зависания (HUP).
    * $ nohup                                          - предотвращает получение процессом, указанным в качестве
                                                         аргумента, сигнала зависания (HUP).
                                                       - будет добавлять (добавлять) любой вывод из процесса задания
    * $ nohup sleep 100 &                              - sleep 10000 в файл под названием nohup.out
    * $ ps -aux | grep sleep                           - посмотреть запущенные в другом терминале процессы
        - 1000 217191 0.0 0.0 32081000 ? S 19:27 0:00 sleep  - где 217191 PID процесса
        - 1000 300914 0.0 0.0 32081072 ? S 19:29 0:00 sleep
    * $ kill 217191                                    - убить процесс
    * $ pkill sleep                                    - убить процесс

    * & disown                                         - при выходе из оболочки: перед выходом она отправляет SIGHUP
                                                         всем запущенным заданиям. Если задание находится в состоянии
                                                         остановки, оболочка отправит ему сигнал SIGCONT для его
                                                         возобновления, чтобы оно могло получить сигнал SIGHUP и
                                                         завершиться.
    * $ disown %2 (по задаче) или 39324 по PID         - отключает от этой конкретной терминальной сессии
    * $ ps -p 798852                                   - посмотреть по PID процесс, выкинутый из этой сессии
    * $ disown -h %1                                   - все еще существует, но оно помечено так, чтобы не получать
                                                         сигнал SIGHUP от оболочки при ее выходе

    * nohup                                            - оставляет процесс в этой сессии но игнорирует сингалы выхода из терминала
    * disown                                           - сразу выкидывает процесс из сессии, поэтому процесс не получит SIGNHUP

### Сигналы
    - SIGCHLD: Этот сигнал посылается родительскому процессу, когда дочерний процесс завершает свою работу или
               останавливается.
    - SIGCONT: Этот сигнал сообщает процессу, который был приостановлен SIGSTOP или SGSTP, возобновить свое выполнение.
               Эти три сигнала используются при управлении заданиями.
    - SIGHUP: Этот сигнал посылается процессу, когда его терминал закрыт, и уничтожает его. Своим названием он обязан
              старым добрым временам, когда соединения осуществлялись по последовательной линии, которая зависала из-за обрыва линии.
    - SIGINT: Это сигнал, подаваемый процессу при нажатии пользователем клавиш <Ctrl + C>, который прерывает процесс,
              завершая его. Этот сигнал может быть проигнорирован процессом.
    - SIGKILL: Этот сигнал немедленно завершает процесс. Этот сигнал не может быть проигнорирован, и процесс должен
               немедленно быть уничтожен, ничего не закрывая и не сохраняя. (kill -9)
    - SIGQUIT: Получив этот сигнал, процесс прекращает выполнение дампа ядра. Дамп ядра - это дамп, копия памяти,
               используемой процессом, поэтому мы можем найти в нем много полезной информации, такой как процессор, регистры, флаги, данные, которые полезны для отладки рабочего состояния самого процесса.
    - SIGSTOP: Этот сигнал посылается для остановки процесса. Он не может быть проигнорирован.
    - SIGTERM: Это запрос на завершение процесса. Это наиболее предпочтительный способ завершения процесса, так как он
               позволяет процессу безболезненно завершить работу, освободив ресурсы и сохранив состояние, а также
               упорядоченно завершить все дочерние процессы. Он может быть проигнорирован процессом (kill -15).
    - SIGTRAP: Это сигнал, посылаемый процессу при возникновении исключения или ловушки. Ловушки мы рассмотрим подробнее.
    - SIGTSTP: Это интерактивная остановка, которую может послать пользователь, нажав <Ctrl+Z>. Процесс может его
               проигнорировать. Процесс приостанавливается в своем текущем состоянии.
    - SIGTTIN: Этот сигнал посылается фоновому процессу при попытке чтения с терминала.
    - SIGTTOU: Этот сигнал посылается фоновому процессу при попытке записи на терминал.
    - SIGSEV: Этот сигнал посылается процессу при ошибке сегментации, которая происходит, когда процесс пытается
              получить доступ к участку памяти, к которому он не имеет права обращаться, или таким образом, который ему не разрешен.

    * $trap -l                                         - список сигналов
             - Сигналы 32 и 33 отсутствуют. Они не реализованы в Linux.
             - Они были заменены функциями компилятора gcc для обработки потоков в реальном времени.
             - Все, от сигнала 34, SIGRTMIN, до сигнала 64, SIGRTMAX, являются сигналами реального времени.
    * $ trap 'echo -e "\nCtrl+c detected."' SIGINT     - Перехват сигнала в командной строке
    * $ trap -p ( $ trap -p SIGINT)                    - посмотреть ловушку
    * $ trap - SIGINT                                  - сбросить
             - ПРОСЛУШКА в скрипте, цикл будет идти постоянно пока не получит сигнал
                 - запуск скрипта chmod +x simple-loop.sh
                 - ./simple-loop.sh
                    #!/bin/bash

                    trap "echo I was SIGINT terminated; exit" SIGINT
                    trap "echo I was SIGQUIT terminated; exit" SIGQUIT
                    trap "echo I was SIGTERM terminated; exit" SIGTERM

                    echo $$
                    counter=0

                    while true
                    do
                      echo "Loop number:" $((++counter))
                      sleep 1
                    done
             - ОБРАБОТКА сигнала в скрипте
                    trap graceful_shutdown SIGINT SIGQUIT SIGTERM

                    graceful_shutdown()
                    {
                      echo -e "\nRemoving temporary file:" $temp_file
                      rm -rf "$temp_file"
                      exit
                    }

                    temp_file=$(mktemp -p /tmp tmp.XXXXXXXXXX)
                    echo "Created temp file:" $temp_file

                    counter=0

                    while true
                    do
                      echo "Loop number:" $((++counter))
                      sleep 1
                    done

### Скрипты
    * $ source hello.sh                     - запуск скрипта в собственной оболочке
    * $ bash hello.sh                       - скрипт выполнил свою работу, а затем вышел и вернулся в свой сеанс
    * $ cat hello.sh | bash                   оболочки, не изменяя никаких настроек
    * $ bash < hello.sh                     - 3 варианта запуска

### Написание сценария shebang
    - самоисполняющийся скрипт, используя в качестве первой строки специальный синтаксис #!, называемый shebang,
      или иногда hash-bang. Этот синтаксис специально обрабатывается ядром и определяет программу, которая должна
      использоваться для выполнения остальной части сценария - интерпретатора.
    * hello.sh                              - скрипт для исполнения самому
        #!/bin/bash
        printf 'Hello, %s!\n' "$USER "
    * $ declape -p BASH                     - посмотреть локальный адрес BASH
        - declare -- BASH="/bin/bash"
    * $ chmod +x hello.sh                   - бит исполняемости (x) для всех пользователей скрипта, что позволит
                                              выполнять его непосредственно как собственную программу,
            - u                             - владелец
            - g                             - группа
            - r                             - только чтение
            - w                             - только запись
            - x                             - только исполняемый файл
    * $ ./hello.sh (либо ./hello)           - запуск уже как программы, можно файл без расширения

### Поиск скриптов
    * $ ./scripts/hello                     - можно вызвать программу из другой, но просто hello не получиться
    * $ declare -p PATH                     - просмотр переменной PATH

### Системный bindir
    - /usr/local/bin, который включается в каталог $PATH каждого пользователя
    - чтобы программа hello была доступна во всей системе, поместить ее в каталог /usr/local/bin
    * $ sudo -s                             - супер пользователь
    * $ mv hello.sh /usr/local/bib          - теперь можно запускать программу hello

### Пользовательский bindir
    - нет прав root, или необходимо, чтобы скрипт был доступен только нам, то другой способ получить нашу программу
    - в каталоге PATH - это создать свой собственный bindir
    - Это может быть любой каталог. Система не требует, чтобы bin был именем директории, но это хорошая идея,
      поскольку так будет понятно, для чего эта директория предназначена
    * $ mkdir /home/volkov/bin
    * $ mv hello /home/volkov/bin
    * $ PATH=$PATH:/home/volkov/bin        - добавив каталог в конец PATH с помощью присваивания переменной :
    * $ type -a hello                      - проверить скрипт через тип
        -a, -p                             - путь, путь вместе с названием файла
        -t                                 - тип файла

### Переменные
        - переменная - это способ хранения значения
        - переменная - ячейка, в которой мы можем хранить некоторую информацию для последующей обработки
        - типа переменной BASH  - строка, и все же правильнее БЕЗ ТИПА
        * $ LABEL=value                    - присвоение переменной значения
        * $ fruits=(aplle banana pear)     - присвоение массива
        * $ echo LABEL                     - получить переменную (типа ссылки)
        * $ echo $LABEL                    - получить значение переменной
        * $ echo ${LABEL}                  - эквивалент получить значение переменной
        * $ echo $NOT_EXIST                - не существующая переменная, вывод будет NULL
        * $ echo ${LABEL} this not Adidas  - конкатенация строк
        * $ LABEL+=$OTHER_LABLE             - конкатенация строк

### Переменные с ограниченной областью применения
        - Переменные, инициализированные внутри скрипта, не передаются в основную оболочку
        * $ sh -x disk-space.sh            - запуск скрипта в режиме отладчик (пошагово)
        * $ print () {                     - сделает видимость переменной только внутри функции, только функция запущена
                local TEST=zdraste         - просто объявить, будет видно везде (типа var JS)
                echo "inside TEST_LOCAL: ${TEST}"
            }

### Расширение переменной
    * $ x=44 ; y=$x ; x=ter ;              - присваивание одной переменной другой, при этом изменив первую не измениться другая
        echo "x is $x ;" ; echo "y is ${y} af"
    - значения и сообщения переменной по умолчанию
        * ${LABEL-default}
        * ${LABEL:-default}
    * $ echo "The space is ${disk_space:-hren} - значение по дефолту по время вызова, если переменной не присвоено значение
    * $ echo "The space is ${disk_space:+hren} - значение наоборот, дефолт если присвоено, если ничего то будет пусто

### Сопоставление шаблонов с переменными
    * $ echo ${#LABEL}                     - длина значения переменной
    * $ echo ${LABEL#pu}                   - убрать из значения из начала (puma)
        - ma                               - вывод
    - удаление наибольшего вхождения в переменную
        * $ test=10101022221003
        * $ echo ${test#1*2}               - удалить от 1 до 2 включительно (удалить наименьшее вхождение)
            - 2221003                      - вывод

        * $ test=pupuma
        * $ echo ${test%u*a}               - удалить наименьшее вхождение с конца от u до a
            - pupu

        * $ test=10101022221003
        * $ echo ${test#1*2}               - удалить от 1 до 2 включительно (удалить наименьшее вхождение)
            - 2221003                      - вывод

        * $ test=10101022221003
        * $ echo ${test##1*1}              - удалить от 1 до последней 1 включительно (удалить наибольшее вхождение)
            - 03                           - вывод

        * $ test=pupuma
        * $ echo ${test%%u*a}               - удалить наибольшее вхождение с конца от u до a
            - p

        * $ test=pupuma
        * $ echo ${test#p*u}               - удалить от p до u
            - puma

        * $ test=dog\ laet
        * $ echo ${test/dog/cat\ ne}       - замена значения на другое (регулярное выражение) наименьшее вхождение
            - cat ne laet

        * $ test=dog\ laet\ dog\ kusaet
        * $ echo ${test//dog/cat\ ne}       - замена значения при выводе я на другое наибольшее вхождение
            - cat ne laet cat ne kusaet

        * $ test=${test//dog/cat\ ne}       - присвоение значения переменной через замену

        * $ test=dog\ laet\ dog\ kusaet

        * $ echo ${test/#"dog"/}            - удаление наименьшего с начала (ничего не передаем)
        * $ echo ${test/#"dog"/"cat no"}    - удаление наименьшего с начала (ничего не передаем)

        * $ test=dog\ laet\ dog
        * $ echo ${test/%"dog"/"cat ne"}    - замена значения при выводе я на другое наименьшее вхождение
            - cat ne laet cat ne            - при окончании на dog

        * $ test=anton ; tuk=tukituki
        * $ name=${!t*}                     - совпадение с именами переменных
            * $ name=${!t@}                 - эквивалент
                - test tuk                  - выведет совпадения с названиями переменных

        * $ test=anton
        * $ echo ${test:2}                  - отрезать после 2 символа все символы до конца
            - ton
        * $ echo ${test:2:1}                - отрезать после 2 только 1 символ

### Специальные переменные
    - передача в скрипт переменных при запуске
    * #!/bin/bash
        name=${1}
        familia=${2}
        age=${3}

        echo "Name: ${name:-defaultName}, familia: ${familia:defaultFamilia}, age: ${age:-defaultAge}"
    * $ bash spec_simbol.sh Anton Volkov 33  - Anton - это переменная $1 и так далее
        - ${0}                              - дает имя файла
        - ${#}                              - дает количество передаваемых переменных
        - ${@} или ${*}                     - дает все передаваемые переменные строкой, @ - сохраняет пробелы
        - ${?}                              - выдает значение выхода последней команды
        - ${$}                              - выдает значение до PID текущей оболочки

    * $ nohup ps &                          - перевод вне оболочки в фон
    * $ echo "!: ${!}"                      - вывод PID последнего PID фонового процесса

### Операторы
    * $ echo $((1+2))                       - сложение чисел
        - - / * % **                        - аналогично
        * $ first=1
        * $ second=2
        * $ echo $((first+second))          - сложение переменных
                - 3                         - вывод

### Операторы присваивания
    - в BASH используется 64 битное число       - -9 223 372 036 854 775 808 до 9 223 372 036 854 775 807
    * $ a=an ; b=ton ; a+=$b ; echo $a          - конкатенация через присваивание
    * $ a=1 ; b=2 ; ((a-=b)) ; echo $a          - вычитание с присвоением переменных
    * $ a=3 ; b=2 ; echo $((a*=b)) ; echo $a    - тоже самое с круглыми скобками
        - - / * % **                            - аналогично

### Унарные операторы
    - ++ --
    -- позици имеет значение
    * $ a=15 ; echo $((a++)) ; echo ${a}
        - 15
        - 16
    * $ a=15 ; echo $((++a)) ; echo ${a}
        - 16
        - 16

### Приоритет операторов
    - операции с более высоким приоритетом выполняются раньше операций с более низким приоритетом.
    - В случае, если приоритеты операторов равны, то операции выполняются слева направо.

## ФУНКЦИИ

## Функции
    * $ home() { printf '%s\n' "$HOME"; }   - пример функции
        * $ set -x                          - вывод действий полный
        * $ set +x                          - выключить вывод действий
    * $ ps() { cd .. && cd .. && ls ;}
    * $ home() { printf '%s\n' "$HOME"; }           - определение функции точка с запятой в этой нотации обязательна
        * $ home                                    - вызов
        * #!/usr/bin/env bash                       - функция в скрипте, можно без точки с запятой
                                                    - после { пробел
            test(){
               printf '%s\n' "$HOME"
             }

            test

            - можно function test() {               - не использовать - sh script.sh - так не сработает
                      printf '%s\n' "$HOME"
                    }

        * $ home() { printf '%s\n' "$HOME"; }
        * $ type hello                              - тип home и вывод содержимого как текст

        * $ mkcd() { mkdir "$1" && cd ${1} ; }      - принимает специальные переменные, двойные кавычки, чтобы
                                                      передать любую строку ('!@#$%^&*()')
            * $  mkcd testdir                       - передача в функцию переменной

        * $ set -x                                  - включить лог выполнения комманд
        * $ set +x                                  - выключить лог выполнения комманд

        * $ mkcd() { mkdir "$1" && cd ${1} ; }      - переопределение, СИСТЕМНЫЕ Лучше не менять (рs() { echo ; }
            * $ mkcd() { echo "pereopredelil" ; }

        * $ unset ps                                - сброс переопределения системной функции ps


### Использование -- для отделения опций от имен файлов
    * $ cat -- manual                       - исользуется как имя файла не передаваемая опция
    * $ mkls() {   mkdir -- "$@" && ls -dl -- "$@" ; }
        - "$@"                              - получить сколько угодно параметров (типа ...спред в JS)
        * $ mkls test test2                 - можно передать 1 параметр или несколько
        * $ mkls test1

### Возврат значений
    - нельзя возращать строки и массивы
    - return используется строго для целых чисел и предназначено для описания успеха или неудачи функции
    * $ succeed() { return 0; }                                     - вернет 0
        * $ succeed ; echo $?                                       - выведет 0
    * $ home() { printf '%s\n' "$HOME" ; }                          - не возвращаем а выводим
        * $ printf '%s\n' "Your home directory is: $(home)"         - используем возвращаемый рез-т
        * $ home | wc -c

### Область видимости функций
    - Функции, использующие фигурные скобки {...} для тела функции, работают в текущем процессе оболочки.
    - задать переменные, видимые только в теле функции, можно использовать ключевое слово local
    -  локальные переменные и ключевое слово local не определены POSIX, они гарантированно работают только в Bash.
    * $ func1() { foo=bar ; printf '%s\n' "$foo" ; }
        * & func1                                                   - выведет bar
        * declare -p foo                                            - переменная выдна вне области видвмости func1
    * $ func2() { local baz ; baz=bazar ; printf '%s\n' "$baz" ; }  - переменная baz будет доступна только внутри func2
        * declare -p baz                                            - -bash: declare: baz: not found
    * $ func3() ( bar=foo ; printf '%s\n' "$bar" ; )                - 2 способ локально, а точнее не будет влиять на текущую оболочку

### Перезагрузка функций при запуске оболочки
    - после перезапуска bash введеные функции не сохранятся
    * $ declare -f home >> ~/.bashrc                                - добавили уже введеную в этом сеансе функцию home
                                                                      при перезапуске она будет доступна
    * $ source ~/.bashrc                                            - перезапуск сеанса

### Функции в скриптах
    * $ #!/bin/bash                                                 - # закоментривать строку
        minor() {                                                   - обьявленная переменная в функции внутри одного скрипта
          varr="$1"                                                   достуна во всем скрипте, НО только после запуска
          if (("$1" < "$2"))                                          функции, где обьявлена переменная
          then                                                      - local перед переменной НЕ Будет доступна в скрипте
          echo "Integer $1 less than $2"                              вне функции
          else
          echo "Integer $1 not less than $2.."
          fi
        }

        minor "$1" "$2"
        echo "$var"
    * $ ./less.sh 44 33
    * $ #!bin/bash                                                  - использование присвоение переменной не как строка,
        FIRST_VALUE=SECOND_VALUE                                      а как переменную через ! (косвенная ссылкя)
        SECOND_VALUE=20
        print_value() {
          echo "The value of \$1 is: $1"
        }
        print_value "${!FIRST_VALUE}"
        exit 0

### Условия
    - в зависимости от типа условие может быть [ ], ()
    - синтаксис if <условие>; then <команда> fi
    - elif                                                          - доп условие
    * $ case $command in                                            - аналог switch
          help) printf 'Command help:\n...' ;;                      - Каждый параметр завершается двумя точками с запятой.
          version) printf 'Command version: 0.1.0\n' ;;
        esac                                                        - Закрывающее ключевое слово
    * $ case $command in
            help|h|usage) printf 'Command help:\n...' ;;            - шаблоны символов
        esac
    * $ case $command in
            debug|verb*)                                            - совпадающие с глобальными объектами: *, ? и [...]
                printf 'Running in verbose mode.\n'                    для проверки на частичные совпадения
                verbose=1
                ;;
            *) printf 'Unknown command\n' ;;                        - "поймать все" или опцию по умолчанию
        esac

## Циклы

### FOR
    * $ for placeholder in list_of_items
        do
          action_1 $placeholder
          action_2 $placeholder
          action_n $placeholderdone
        done
    * $ for i in {10..1..5}                                         - от 10 каждый шаг +5
        do
          echo "$i"
        done
    * $ for i in *; do echo "$i"; done                              - в одну строку
    *$ for (( i = 0; i < 5; i++ )); do                              - в стиле C
           echo "By C style $i"
       done

### WHILE
    * $ i=5                                                         - выполняет пока true, как ложно закончит
        while  (( i > 0)); do
            echo "$((i--))"
        done
    * $ a=1                                                         - выполняется пока ложно, как true закончит
        until (( a > 5)); do
            echo "$((a++))"
        done

    * while true                                                    - бесконечный цикл с паузой и очисткой
      do
        clear
        echo "This text will dead from 3 seconds"
        sleep 1
        clear
        echo "This text will dead from 2 seconds"
        sleep 1
        clear
        echo "This text will dead from 1 seconds"
        sleep 1
        clear
      done
    - break                                                         - выход из цикла
    - continue                                                      - переход на следующую итерацию цикла

### Считывание данных пользователя при помощи циклов
    * $ echo "Select fruit"                                         - выводит список и слушает вводимые элемент списка
        select item in apple banana orange;                           с которым можно работать в итерации цикла
        do
          echo "You $item (Option $REPLY)"

          case "$item" in
              apple)
                echo "Goodbay gnida"
                break
                ;;
              *)
                echo "Choice again"
            ;;
          esac
        done

### CLI, передавая аргументы в командную строку Getops
    - эффективный разбор переключателей и аргументов, передаваемых в командной строке скрипта
    - синтаксис getops options variable
        - опции -a, -x, -f, либо axf
        - если : getops ax:f                                -  данная опция должна иметь аргумент
    * OPTARG   - аргумент для опции или флаг для неизвестной опции.
    * OPTBIND  - индекс следующей опции для разбора.
    * OPTERR   - имеет значение 0 или 1 и задает отображение сообщений об ошибках, выдаваемых getops.
                 По умолчанию значение равно 1, поэтому сообщения выводятся именно здесь.
    * $ if (( $# == 0 ))                                        - проверка передаваемых опций или агрументов
        then
           echo "Please, give at least one option on the command line"
        exit 1
        fi

        while getopts "ax:f" option                             - считывание getopts, и запись их в options
        do                                                      - опция здесь -a, -f
          case $option in                                       - аргумент и значение -x
          a | f)
            echo "You selected $option"
          ;;
          x)
            echo "You selected $option with argument $OPTARG"
          ;;
          ?)
            echo "Invalid switch: -$OPTARG"
          ;;
          :)
            echo "No argumenrs provided: -$OPTARG"
          ;;
          esac
        done
        echo "$OPTIND And the argument was $OPTIND"            - OPTIND - сюда записывается getopts , -1 сдвиг назад на
        shift "$((OPTIND-1))"                                             предыдущий аргумент
        echo "And the argument was $*"                         - OPTIND что-то типа массива с индексами аргументами,
           * $  ./getops.sh -f -a -x hello -a                  - передача аргументов и опций

    - создание своей библиотеки команд
        - /library.lib
            * $ non_zero_input()
                {
                  if (( $1 == 0 ))
                    then
                  echo "Please, give at least one option on the command line"
                  exit 1
                  fi
                }
        - ./getopts.sh                                          - использование библиотеки
            * source library.lib                                - подключение файла source name_file.ext
              non_zero_input "$#"                               - запуск функции с передачей аргументов

## Операторы сравнения и логические операторы

### Операторы сравнения
    - Между двоичным оператором и операндами должно быть пустое место.
    - Всегда используйте двойные кавычки вокруг имен переменных, чтобы избежать проблем с разделением или разбиением слов.
    - Bash не разделяет переменные по «типу», переменные рассматриваются как целые или строковые в зависимости от контекста
    - == !+                                         - равенство, не равенство
    - str =~ str2                                   - равенство с регулярным
    - str > str2                                    - больше меньше по алфавиту
    - текстовые аналоги
        -eq[ $x -eq $y]                             - равно
        -ne, -gt, -lt, -ge, -le                     - не равно, больше, меньше, больше или равно, меньше или равно
    * $ if [ "$VAR1" = "$VAR2" ]; then
    * $ if [[ "$VAR1" = "$VAR2" ]]; then            - три одинаковые записи
    * $ if [[ "$VAR1" == "$VAR2" ]]; then

### Проверка строки на содержание подстроки
    * $ if [[ "$VAR1" =~ .*nto*. ]]; then
    * $ if [[ -z "$VAR1" ]]; then                   - пустая или нет
    * $ if [[ -n "$VAR1" ]]; then                   - пустая или нет

## Побитовые операторы

### Сдвиг (<< >>)
    - Оператор побитового сдвига влево просто умножает на 2 значение для каждой позиции сдвига
    - сдвиг вправо - это отличный метод деления числа на 2 в каждой позиции, то есть деление по мощности 2 со сдвигом
      бита вправо. Обратите внимание, что эта операция сдвигает влево старший бит, то есть бит знака, поэтому
      все будет сдвинуто на единицу
    * $ x=10 ; echo $((x<<1)                        - добавляет один 0 в конец
        - dec(10) == bin(1010)  1010<<1 = 10100 (dec(20)
        - dec(10) == bin(1010)  1010<<2 = 101000 (dec(40)
    - если представить в виде степеней двоек 10
        64 32 16 8 4 2 1
        0  0  0  1 0 1 0 - это 10
                 8   2   - сумма степенй 2
                         - умножаем каждое значение на 2 (<<1)
                 16  4   - получаем 20
                 32  8   - сдвигаем еще на (<<1), если сразу на <<2 тогда умножаем на 4 (сдвиг на два ноля)
        0  0  1  0 1 0 0 - 20
        0  1  0  1 0 0 0 - 40
                         - сдвиг в право делим на 2 либо убираем 0
           32    8       - >>1
           16    4       - получаем 20
        0  0  1  0 1 0 0 - 20

### Побитовое И
    - Оператор побитового И аналогичен логическому И, но работает по битовой маске в двоичном представлении целого числа.
      Двоичные биты считываются слева направо и сравниваются между собой: если в одной и той же позиции каждого
      из чисел мы найдем 1, то результатом будет 1, в противном случае - 0:

      * $ # будет 0
          # 01010
          # 10100
          # 00000
          x=10 ; y=20 ; echo $((x&y))

          # будет 8
          # 001010
          # 101000
          # 001000
          x=10 ; y=40 ; echo $((x&y))

### Побитовое ИЛИ
    - Оператор побитового ИЛИ аналогичен инклюзивному ИЛИ и проверяет два целых числа, используя их двоичное представление:
      если в одной и той же позиции каждого числа стоит хотя бы 1, то результатом будет 1:
    * $ # будет 30
        # 01010
        # 10100
        # 11110
        # 16 8 4 2 0
        x=10 ; y=20 ; echo $((x|y))

### Побитовое Исключающее ИЛИ (^)
    - Это то, что мы называем исключительным OR или XOR: результат будет равен 1 только в том случае, если в том же
      слоте находится только 1, а если две 1, то результат будет равен 0:
      * $ # будет 34
          # 001010
          # 101000
          # 100010
          # 32 0 0 0 2 0   - 34
          # 32 16 8 4 2 0
          x=10 ; y=40 ; echo $((x^y))

### Побитовое НЕ (~)
    - Побитовый оператор NOT является унарным, а это означает, что он используется только с одним оператором,
      переворачивающим бит, используемый для представления целого числа в двоичной системе счисления:
    * $ # будет -11                                 - используется 64 бита, и старший бит инвертируется
        # 00001010
        # 11110101
        # -128 64 32 16 0 4 0 1 = -11
        # -128 64 32 16 8 4 2 1
        x=10 ; echo $((~x))

### Логическое НЕ (!) NOT
    * $ if [[ ! 12 -eq11 ]] then                    - если ложно сохранит как истину

### Логическое AND (&&)
    - Оператор AND проверяет успешность выполнения двух или более выражений и считается истинным, если все условия верны

### Логическое ИЛИ (||)
    - Оператор OR проверяет успешность двух или более выражений и считается истинным

### Оператор запятой (,)
    - это оператор запятая, который используется для объединения арифметических операций в цепочку.
      При этом оцениваются все операции, но возвращается только значение последней из них:
    * $ echo $((x=1, 7-2))
        5
        echo ${x}
        1

### Управление учетными записями пользователя
    - пользователю назначается новая группа с тем же именем пользователя
    * $ sudo useradd testuser                                           - создать пользователя
    * $ id testuser                                                     - проверка создания пользователя
        - uid=1001(testuser) gid=1002(testuser) groups=1002(testuser)
    * $  sudo nano /etc/passwd                                          - просмотр пользователей

    - После создания пользователя с помощью приведенной выше команды вы заметите,
      что внутри каталога /home не было создано никаких пользовательских каталогов
    * $ sudo useradd -m -s /bin/bash testuser2                          - создание пользователя и каталога для него
    * $ sudo passwd testuser2                                           - пароль для пользователя

    * $ sudo adduser testuser3                                          - создать пользователя со паролем и каталогом
    * $ sudo deluser testuser                                           - удалить пользователя без каталога
    * $ sudo deluser --remove-home testuser2                            - удалить пользователя и его каталог

### Управление пользователями группы
    - Группа — это совокупность пользователей. Основная цель групп — определить набор привилегий, таких как разрешение
      на чтение, запись или выполнение для данного ресурса, который может быть совместно использован пользователями в группе.
    * $ cat /etc/group                                                  - просмотр всех групп
    * $ sudo groupadd section                                           - создать группу section
    * $ sudo usermod -aG section testuser                               - добавить в группу пользователя
    * $ sudo gpasswd -d testuser section                                - удалить из группы пользователя
    * $ sudo groupdel section                                           - удалить группу

### Права и ограничения пользователя
    - уровень безопасности BASH
        - rbash - оболочка, имеющая ограниченные возможности пользователей - запуск Bash с ограничениями
        - bash --restricted, -r
            - Пользователь не может изменить каталог с помощью встроенного компакт-диска.
              Пользователю будет запрещено устанавливать или отменять значения для следующих переменных окружения:
                - BASH_ENV
                - ENV
                - SHELL
                - PATH
            - Пользователь не сможет указывать имена команд с косой чертой, и это означает отсутствие имен команд
              с абсолютными путями. Никакие имена файлов, содержащие косую черту, не могут быть переданы в качестве
              аргумента вызываемой встроенной команде .. Таким образом, пользователь не сможет получить исходный код
              (команду чтения и выполнения из) файла из-за пределов своего домашнего каталога.
            - Никакое имя файла, содержащее косую черту, не может быть передано в качестве аргумента встроенной
              команде под названием hash с использованием параметра -p. Хэш определяет полное имя файла команды,
              указанной в качестве аргумента, путем поиска в каталогах, указанных переменной окружения: $PATH.
               Если в качестве параметра указано -p filename, hash будет использовать имя файла в качестве полного
               пути к искомой команде. Таким образом, никакие команды не вызываются за пределами домашнего каталога.
            - Определения функций не импортируются при запуске из среды оболочки.
            - При запуске не учитывается значение переменной environment SHELLOPTS, и поэтому для оболочки не
              задаются параметры оболочки.
            - Переадресации с использованием стандартных операторов запрещены >, >|, <>, >&, &>, >>.
            - Встроенный exec недоступен для замены оболочки другой командой.
            - Невозможно добавлять или удалять встроенные команды, используя опции enable builtin with -d или -f.
            - Невозможно использовать встроенную опцию enable для включения или отключения встроенных модулей Bash.
            - Параметр -p не разрешен для встроенной команды, поэтому никакие манипуляции с $PATH невозможны.
            - Невозможно отключить режим с ограниченным доступом, используя set +r или set +o restricted.
    * $ which bash                                                     - проверить ссылку Bash и перенаправить на rbash
        /bin/bash
        root:# which rbash
        /bin/rbash
        root:# ls -lah /bin/rbash
        lrwxrwxrwx 1 root root 4 Nov 5 2016 /bin/rbash -> bash          - связь уже существует
    * $ cat /etc/shells                                                 - проверить, что rbash указан в /etc/shells
        # /etc/shells: valid login shells
        /bin/sh
        /bin/dash
        /bin/bash
        /bin/rbash
    * $ sudo adduser --shell /bin/rbash restricted                      - создание ограниченного пользователя

### Права доступа к файлам
    - umask (user file creation mode mask — маска режима создания пользовательских файлов) — функция среды POSIX,
      изменяющая права доступа, которые присваиваются новым файлам и каталогам по умолчанию.
      * $ rintf 'Hello, world\n' > myfile $ ls -l myfile -rw-r--r-- 1 bashuser  -  создание файла с правами
        - -rw-r--r--                            - разрешения файла
            - -                                 - первый символ (-) тип файла, в случае директории был бы (d)
            - rw-                               - чтение, запись, выполнение для владельца, (-) нельзя исполнять этот файл как программу
            - r--                               - групповые разрешения, члены здесь группы могут читать но не исполнять
            - r-- (последние)                   - разрешения для остальных, которые не владельцы и не члены группы,
                                                    здесь могут читать но исполнять
    * $ stat -c %a new_file                     - посмотреть в  компактном формате
        - 777                                   - значение вычисляется путем сложения 4 для каждого бита чтения,
           - все разрешения доступны            - 2 для каждого бита записи и 1 для каждого бита выполнения
        - например 644
            - Владелец имеет права на чтение и запись, поэтому первое значение равно 4 + 2, или 6.
            - Группа имеет привилегии только на чтение, поэтому второе значение равно только 4
            - Все остальные имеют права только на чтение, поэтому третье значение равно 4.

### Выбор разрешений для созданных файлов
    - следует учитывать, что все остальные пользователи системы имеют право на чтение файла
    - перед созданием файла проверяется значение umask процесса, чтобы выяснить, какие из этих разрешений
      он не должен применять к созданному файлу.
    * $ umask                                   - Проверить текущее значение umask для оболочки Bash
        0022                                    -  лишний ноль в начале - обычный префикс для обозначения восьмеричного числа.
            - 0: Не снимать привилегии владельца с создаваемого файла.
            - 2: Лишить созданный файл прав на запись для групп,
                 но оставить права на чтение и выполнение.
            - 2: Лишить созданный файл прав на запись для всех остальных
                 пользователей, но оставить права на чтение и выполнение.
    * $ umask -S                                - полное значение umask
        u=rwx,g=rx,o=rx
    - 0	разрешения отсутствуют	---
      1	x — запуск	--x
      2	w — изменение	-w-
      3	x+w — запуск+изменение	-wx
      4	r — чтение	r--
      5	r+x — чтение+запуск	r-x
      6	r+w — чтение+изменение	rw-
      7	r+w+x — чтение+изменение+запуск	rwx
    -   400	-r--------	Владелец файла может только читать файл. Для всех остальных все действия с файлом запрещены.
        644	-rw-r--r--	Все пользователи могут читать файл. Владелец может изменять файл.
        660	-rw-rw----	Владелец и группа могут читать и изменять файл. Для всех остальных все действия с файлом запрещены.
        664	-rw-rw-r--	Все могут читать файл. Владелец и группа могут изменять.
        666	-rw-rw-rw-	Все могут читать и изменять файл.
        700	-rwx------	Владелец может читать, изменять и запускать файл. Для всех остальных все действия с файлом запрещены.
        744	-rwxr--r--	Все могут читать файл. Владелец может также изменять и запускать файл.
        755	-rwxr-xr-x	Все могут читать и запускать файл. Владелец может также изменять файл.
        777	-rwxrwxrwx	Все пользователи могут читать, изменять и редактировать файл.
    - u	Владелец-пользователь.
      g	Группа.
      o	Все остальные.
      a	Вообще все.
    - +	Добавляет к текущим правам доступа новое разрешение.
      -	Удаляет из текущих прав доступа определенное разрешение.
      =	Устанавливает полностью новые разрешения (предыдущие перезаписываются новыми).
    - chmod (владелец)(математическая операция)(разрешения) имя_файла
        * $ chmod g=rw myfile2                      - для группы мы устанавливаем права доступа на чтение и запись файла
        * $ chmod u-w myfile3                       - Для владельца файла (u) мы удаляем разрешение на изменение (w) файла.
        * $ chmod +x myfile1                        - разрешения устанавливаются для всех пользователей. «+x» означает —
          * $ chmod a+x myfile1 (аналог)              установить разрешение на запуск (x) файла для всех пользователей.
    * $ chmod -R 644 Mydir                          - рекурсивная установка прав на все файлы в директории

### Псевдонимы/алиасы
    - Псевдонимы - это быстрый и простой способ сделать так, чтобы одна команда обозначала одну большую команду,
      выраженную в виде строки. Это, пожалуй, самый известный способ настройки поведения в оболочке Bash,
      но и наименее гибкий.
    * $ alias ll='ls -l'                            - создание нового алиаса
        * $ ll for.sh
        * $ ll
    * $ type -a ll                                  - просмотр алиаса
    - Одна из самых больших проблем заключается в том, что они не имеют возможности изменять свое поведение
      в зависимости от переданных аргументов. Они представляют собой простые текстовые подстановки.
    - Другая проблема с псевдонимами заключается в том, что их вызов в сценариях Bash не работает,
      т.к они предназначены только для использования в интерактивном режиме
    - при их определении не выдается никакой ошибки - они просто не работают при вызове, поэтому трудно определить,
      что именно пошло не так
    - Еще больше усложняет ситуацию то, что в некоторых других оболочках псевдонимы действительно работают в скриптах.
    - Лучше избегать всей этой неразберихи, всегда используя вместо них функции, которые работают одинаково во всех оболочках семейства POSIX.

### Системные переменные
    - Каждый раз при запуске сеанса оболочки запускается процесс сбора и компиляции информации,
      которая должна быть доступной процессу оболочки и его дочерним процессам. Он получает данные для этих настроек
      из самых разнообразных файлов и настроек в системе.
    - Окружение предоставляет среду, через которую процесс оболочки может получать или задавать настройки и,
      в свою очередь, передавать эти настройки его дочерним процессам.
    - Окружение реализуется в виде строк, которые содержат пары ключ-значение. Если передается несколько значений,
      они обычно разделяются двоеточием (:).
    - KEY=value1:value2:..
    - KEY="value with spaces"                       - Если значение содержит значительное количество пробелов, используются кавычки
    - Ключи в этих случаях являются переменными. Они могут относиться к одному из двух типов:
      переменные окружения или переменные оболочки.
    - Переменные окружения — это переменные, определяемые для текущей оболочки и наследуемые любыми дочерними
      оболочками или процессами.
      Переменные окружения используются для передачи информации процессам, которые запущены в оболочке.
    - Переменные оболочки — это переменные, содержащиеся исключительно в оболочке, внутри которой они были заданы
      или определены. Часто они используются для отслеживания кратковременных данных, например текущего рабочего каталога.
    - эти типы переменных обычно определяются с помощью заглавных букв

###  Переменные окружения
    * $ env                                     - просмотр переменных окружения
    * $ export TEST_VAR=awesome                 - объявление переменной (создание(
    * $ echo $TEST_VAR                          - чтение переменной
    * $ unset TEST_VAR                          - удаление переменной
    - Переменная окружения    Использование
        BASH_VERSION            Версия текущего сеанса Bash
        HOME                    Домашний каталог текущего пользователя
        HOSTNAME                Имя хоста
        LANG                    Язык, используемый для управления данными
        PATH                    Путь поиска для оболочки
        PS1                     Конфигурация командной строки
        PWD                     Путь к текущему каталогу
        USER                    Имя пользователя, вошедшего в систему в данный момент
        LOGNAME                 То же самое, что и user
    * $ ./setting.sh
        #!/usr/bin/env bash
        export MYTEST=NOWAY                     - переменная MYTEST будем доступна внутри скрипта и во время исполнения
        env | grep MYTEST
        echo ${MYTEST}


        * $ ./setting.sh  ; echo ${MYTEST}              - переменная MYTEST будем доступна внутри скрипта и во время исполнения
            MYTEST=NOWAY
            NOWAY
        * $ echo ${MYTEST}                              - уже ничего не выведет
    - когда оболочке нужно вызвать программу или скрипт, она просматривает содержимое переменной окружения PATH,
      чтобы найти ее в одном из перечисленных путей. Если ее там нет, то исполняемый файл или скрипт не может быть
      вызван просто по имени, его нужно вызывать, передавая полный путь к нему
    * $ echo "Time for magic!"
        echo  "We are looking for the setting.sh script!"
        env PATH=/usr/bin which setting.sh              - env: эта команда способна обойти переменную окружения PATH и
                                                          передать собственную переменную и связанное с ней значение

### Переменные оболочки
    * $ TEST_VAR='hello'                                - создание переменной оболочки, переменная доступна
                                                          в нашем текущем сеансе, но она не будет передаваться дочерним процессам.
    * $ set | grep TEST_VAR                             - поиск переменной в переменных окружения (ее там не будет)
    * $ printenv | grep TEST_VAR                        - вывод переменных окружения (ее тоже там не будет)
    - переменные оболочки, которые вам могут встречаться на вашем пути изучения bash:
        - BASHOPTS: список опций, которые использовались при исполнении bash. Это может быть полезно, если вам нужно узнать,
                    будет ли окружение оболочки работать так, как вы хотите.
        - BASH_VERSION: используемая версия bash, описанная в понятной человеку форме.
        - BASH_VERSINFO: версия bash в машиночитаемом виде.
        - COLUMNS: количество столбцов, используемых для отображения вывода на экране.
        - DIRSTACK: стек каталогов, доступных с помощью команд pushd и popd.
        - HISTFILESIZE: количество строк истории команды, хранящейся в файле.
        - HISTSIZE: количество строк истории команды, допустимое для хранения в памяти.
        - HOSTNAME: имя хоста компьютера в настоящий момент.
        - IFS: внутренний разделитель поля для выделения ввода в командной строке. По умолчанию используется пробел.
        - PS1: определение первичного приглашения ввода. Эта опция используется для определения того, как будет
               выглядеть ваше приглашение при запуске сеанса оболочки. PS2 используется для объявления вторичного приглашения для случаев, когда команда использует несколько строк.
        - SHELLOPTS: опции оболочки, которые можно задать с помощью опции set.
        - UID: уникальный идентификатор текущего пользователя.

### Разница между переменной окружения и оболочки
    - очень осторожны при работе с переменной окружения.
    - Реальная разница проявляется, когда у нас есть подпроцесс, который выполняется системным вызовом execve():
      в этом случае переменная оболочки не передается. Нам нужно будет экспортировать его, чтобы сделать доступным для подоболочки.

### Понижение и сброс переменных
    - TEST_VAR все еще определена в качестве переменной окружения (смотри выше)
    * $ export TEST_VAR             - будет переменной окружения, но при этом останется переменной оболочки
    * $ unset TEST_VAR              - сбросить переменную, как оболочки, так и окружения